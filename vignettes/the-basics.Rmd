---
title: "Getting Started with networkformat"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with networkformat}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message = FALSE}
devtools::load_all()
# library(networkformat)
```

**networkformat** turns tree-based models and tabular data into network
(graph) objects you can analyze with igraph, tidygraph, and ggraph. It has two
functions:

- `edgelist()` --- extract edges (parent-child or source-target relationships)
- `nodelist()` --- extract node-level attributes

Both are S3 generics that dispatch on the class of their input.

# From a decision tree to a network plot

Fit a classification tree, extract edges and nodes, and plot --- all in a few
lines.

```{r tree-quick, eval = requireNamespace("tree", quietly = TRUE) && requireNamespace("igraph", quietly = TRUE), message = FALSE}
library(igraph)

tr <- tree::tree(Species ~ Sepal.Length + Sepal.Width, data = iris)

edges <- edgelist(tr)   # from, to, label
nodes <- nodelist(tr)   # node, var, n, dev, yval, is_leaf

g <- graph_from_data_frame(edges, directed = TRUE,
       vertices = data.frame(name = nodes$node, nodes[-1]))
```

`edgelist()` returns a data.frame of parent-child edges with the split
condition in `label`. `nodelist()` returns one row per node --- the split
variable, sample size, deviance, predicted value, and a leaf indicator. The
node IDs line up, so you can hand them straight to igraph.

```{r tree-quick-print, eval = requireNamespace("tree", quietly = TRUE)}
edges
nodes
```

## Visualizing the tree with ggraph

```{r tree-ggraph, eval = requireNamespace("tree", quietly = TRUE) && requireNamespace("ggraph", quietly = TRUE), fig.width = 10, fig.height = 7}
library(ggraph)
library(tidygraph)

# Build display labels
nodes$node_label <- ifelse(nodes$is_leaf,
  paste0(nodes$yval, "\nn=", nodes$n),
  paste0(nodes$var,  "\nn=", nodes$n))

# Threshold only (variable name is on the parent node)
edges$threshold <- gsub("^\\S+\\s+", "", edges$label)

tg <- tbl_graph(
  nodes = data.frame(name = nodes$node, nodes[c("yval", "is_leaf", "n", "node_label")]),
  edges = edges)

species_pal <- c(setosa = "#66c2a5", versicolor = "#fc8d62", virginica = "#8da0cb")

ggraph(tg, layout = "tree") +
  geom_edge_diagonal(colour = "grey50", width = 0.5) +
  geom_edge_diagonal(aes(label = threshold),
    angle_calc = "along", label_dodge = unit(3, "mm"),
    label_size = 2.3, label_colour = "grey30", colour = NA) +
  geom_node_label(aes(label = node_label, fill = yval),
    size = 2.5, colour = "white", fontface = "bold",
    label.padding = unit(0.25, "lines"), label.r = unit(0.2, "lines")) +
  scale_fill_manual(values = species_pal, name = "Predicted class") +
  theme_graph(base_family = "sans") +
  theme(legend.position = "bottom") +
  labs(title = "Iris classification tree",
       subtitle = "Split on Sepal.Length and Sepal.Width")
```

Internal nodes show the split variable; leaf nodes show the predicted class.
Edge labels give the threshold for each branch.

# From a random forest

`edgelist()` and `nodelist()` iterate over every tree in the forest and stack
the results, tagging each row with `treenum`.

```{r rf-extract, eval = requireNamespace("randomForest", quietly = TRUE), message = FALSE}
library(randomForest)

rf <- randomForest(Species ~ ., data = iris, ntree = 3, maxnodes = 5)

rf_edges <- edgelist(rf)
rf_nodes <- nodelist(rf)

head(rf_edges)
head(rf_nodes)
```

To work with a single tree, filter both data frames on `treenum`:

```{r rf-single, eval = requireNamespace("randomForest", quietly = TRUE)}
t1_edges <- subset(rf_edges, treenum == 1)
t1_nodes <- subset(rf_nodes, treenum == 1)
t1_edges
```

You can then pass `t1_edges` and `t1_nodes` to igraph the same way as the
single-tree example above.

# From a data frame

If your data is already tabular --- say a list of courses with prerequisites
--- `edgelist()` and `nodelist()` reshape it for igraph.

## The `courses` dataset

```{r courses-show}
courses
```

Six university courses. `course` identifies each node; `prereq` and
`crosslist` define two kinds of edges; `dept`, `credits`, and `level` are
node attributes.

## Building a course network

`edgelist()` extracts one edge type at a time. Build prerequisites and
crosslists separately, tag them, and combine:

```{r df-workflow, eval = requireNamespace("igraph", quietly = TRUE), message = FALSE}
library(igraph)

courses <- edgelist(courses, source_cols = course, target_cols = c(prereq, crosslist) ))

prereqs <- edgelist(courses, source_cols = course, target_cols = prereq)
prereqs <- prereqs[complete.cases(prereqs), ]
prereqs$type <- "prerequisite"

crosslists <- edgelist(courses, source_cols = course, target_cols = crosslist)
crosslists <- crosslists[complete.cases(crosslists), ]
crosslists$type <- "crosslist"
# Crosslists are symmetric — keep one direction per pair
crosslists <- crosslists[as.character(crosslists$source) <
                          as.character(crosslists$target), ]

all_edges <- rbind(prereqs, crosslists)
nodes     <- nodelist(courses, id_col = course)

g <- graph_from_data_frame(all_edges, vertices = nodes)
```

`source_cols`, `target_cols`, and `id_col` accept bare column names, quoted
strings, or numeric indices --- anything
[tidyselect](https://tidyselect.r-lib.org/reference/language.html) supports.

```{r df-print, eval = requireNamespace("igraph", quietly = TRUE)}
all_edges
nodes
```

```{r df-plot, eval = requireNamespace("igraph", quietly = TRUE) && requireNamespace("ggraph", quietly = TRUE), fig.width = 8, fig.height = 5.5}
library(ggraph)
library(tidygraph)

tg <- as_tbl_graph(g)

# Node order: stat101, stat102, stat202, math101, math102, data202
# Crosslisted pairs sit side-by-side; all prereqs fan into stat101
coords <- matrix(c(
    0,     0,      # stat101 — prereq hub
   -0.75,  1,      # stat102
    0.75,  1,      # stat202
    0,    -1.2,    # math101 — foundation
   -0.3,   1,      # math102 (crosslisted with stat102)
    0.3,   1       # data202 (crosslisted with stat202)
), ncol = 2, byrow = TRUE)

dept_pal <- c(STAT = "#5B8DB8", MATH = "#E07B54", DATA = "#6BAF6B")

ggraph(tg, layout = "manual", x = coords[,1], y = coords[,2]) +
  geom_edge_link(
    aes(filter = (type == "prerequisite")),
    arrow = arrow(length = unit(2.5, "mm"), type = "closed"),
    end_cap = circle(14, "mm"), start_cap = circle(14, "mm"),
    edge_width = 0.5, colour = "grey45") +
  geom_edge_link(
    aes(filter = (type == "crosslist")),
    end_cap = circle(14, "mm"), start_cap = circle(14, "mm"),
    edge_width = 0.4, colour = "#B07CC6", linetype = "dashed") +
  geom_node_label(
    aes(label = name, fill = dept),
    colour = "white", fontface = "bold", size = 3.5,
    label.padding = unit(0.35, "lines"), label.r = unit(0.25, "lines")) +
  scale_fill_manual(values = dept_pal, name = "Department") +
  coord_cartesian(clip = "off", xlim = c(-1.15, 1.15)) +
  theme_graph(base_family = "sans") +
  theme(legend.position = "bottom",
        plot.margin = ggplot2::margin(5, 15, 5, 15)) +
  labs(title = "Course network",
       subtitle = "Solid arrows = prerequisites  |  Dashed lines = crosslists")
```

All four upper-level courses require stat101, which in turn requires math101.
Dashed purple lines connect crosslisted pairs across departments --- note that
crosslisted courses share the same prerequisite.

# Output reference

## edgelist()

| Input class | Columns returned |
|-------------|-----------------|
| `data.frame` | `source`, `target` |
| `tree` | `from`, `to`, `label` |
| `randomForest` | `source`, `target`, `split_var`, `split_point`, `prediction`, `treenum`, `split_var_name` |

## nodelist()

| Input class | Columns returned |
|-------------|-----------------|
| `data.frame` | Reordered input (ID column moved to position 1) |
| `tree` | `node`, `var`, `n`, `dev`, `yval`, `is_leaf` |
| `randomForest` | `node`, `is_leaf`, `split_var`, `split_var_name`, `split_point`, `prediction`, `treenum` |

Node IDs in `nodelist()` always correspond to the edge endpoints in
`edgelist()` for the same object, so you can pass both directly to
`igraph::graph_from_data_frame()`.
