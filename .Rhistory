packageVersion("devtools")
#> [1] '2.4.6'
packageVersion("devtools")
library(devtools)
use_r("edges")
load_all()
check()
check()
use_mit_license()
document()
?edges.randomForest
use_testthat()
use_test()
use_test()
use_test()
mtcars
test_that("edges on randomForest produces data frame", {
# skip_if_not_installed("randomForest")
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
expect_type(edgelist, "data.frame")
})
??test_that
library(testthat)
#note: it is better to test user-facing functions -
test_that("edges on randomForest produces data frame", {
# skip_if_not_installed("randomForest")
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
expect_type(edgelist, "data.frame")
})
#note: it is better to test user-facing functions -
test_that("edges on randomForest produces data frame", {
# skip_if_not_installed("randomForest")
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
expect_type(edgelist, "data.frame")
})
load_all()
#note: it is better to test user-facing functions -
test_that("edges on randomForest produces data frame", {
# skip_if_not_installed("randomForest")
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
expect_type(edgelist, "data.frame")
})
load_all()
#note: it is better to test user-facing functions -
test_that("edges on randomForest produces data frame", {
# skip_if_not_installed("randomForest")
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
expect_type(edgelist, "data.frame")
})
methods(edges)
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
typeof(rf)
class(rf)
exists("edges.randomForest")
methods("edges")
class(rf)
load_all()
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
methods("edges")
?methods
document()
library(devtools)
document()
document()
load_all()
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
expect_type(edgelist, "data.frame")
load_all()
document()
document()
load_all()
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
expect_type(edgelist, "data.frame")
View(edgelist)
class(edgelist)
typeof(edgelist)
test_that()
test_that()
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
expect_class(edgelist, "data.frame")
library(testthat)
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
expect_class(edgelist, "data.frame")
# skip_if_not_installed("randomForest")
library(randomForest)#simplify?
rf <- randomForest(mpg ~ ., data = mtcars)
edgelist <- edges(rf)
expect_s3_class(edgelist, "data.frame")
pacman::p_load(tidyverse, randomForest)
#load data
Auto <- ISLR2::Auto
glimpse(Auto)
forest1 <- randomForest(formula = mpg ~ . -name, data = Auto, importance = TRUE, ntree = 3)# make a small forest
forest2 <- randomForest(formula = as.factor(mpg) ~ . -name, data = Auto, importance = TRUE)
out <- edgelist.randomForest(forest1)
plot1
pacman::p_load(tidyverse, randomForest)
#load data
Auto <- ISLR2::Auto
glimpse(Auto)
forest1 <- randomForest(formula = mpg ~ . -name, data = Auto, importance = TRUE, ntree = 3)# make a small forest
forest2 <- randomForest(formula = as.factor(mpg) ~ . -name, data = Auto, importance = TRUE)
out <- edges.randomForest(forest1)
pacman::p_load(tidyverse, randomForest)
#load data
Auto <- ISLR2::Auto
glimpse(Auto)
forest1 <- randomForest(formula = mpg ~ . -name, data = Auto, importance = TRUE, ntree = 3)# make a small forest
forest2 <- randomForest(formula = as.factor(mpg) ~ . -name, data = Auto, importance = TRUE)
out <- edges.randomForest(forest1)
ff <- forest1$forest
# View(ff)
ff |>
summary()
ff2 <- forest2$forest
ff$nodestatus[,1]
ff$leftDaughter[,1]
ff$rightDaughter[,1]
ff$nodepred[,1]
ff$bestvar[,1]
ff$xbestsplit[,1]
tree1 <- getTree(forest1, 1)# using this function is probably more future-proof than relying on object staying the same
tree1 |> head()
tree1[,"status"] |> unique()
unique(tree1)
# why are these -3 status? docs claim it should be -1 or 1
tree2 <- getTree(forest2, 1)
tree2 |> head()
# unique()
# efficiency doesn't matter, write it first then make it fast
convert_tree <- function(treenum){
tree1 <- getTree(forest1, treenum)
tree1 <- as.data.frame(tree1)
tree1$index <- c(1:nrow(tree1))
parent_index <- tree1$`left daughter` != 0
edgelist <- data.frame(source = c(tree1[parent_index,"index"], tree1[parent_index,"index"]),
target = c(tree1[parent_index,"left daughter"], tree1[parent_index,"right daughter"]),
split_var = c(tree1[parent_index,"split var"], tree1[parent_index,"split var"]),
split_point = c(tree1[parent_index,"split point"], tree1[parent_index,"split point"]),
prediction = c(tree1[parent_index,"prediction"], tree1[parent_index,"prediction"]))
# structure is here (for one tree). but u can add the variable names I guess
# you can do some kind of default thing.
# idk uhhhhh labels for prediction?????
#
return(edgelist)
}
# edgelist$split_var |> unique()
forest_edge <- data.frame()
# is most efficient way adding to a list?
for(i in 1:forest1$ntree){
forest_edge <- rbind(forest_edge, convert_tree(i))
}
# do for all trees then attach varnames
forest_edge <- out
g <- igraph::graph_from_data_frame(forest_edge)
# graph is wrong bc source target aren't uniquely identified
library(ggraph)
ggraph(g) +
geom_edge_link(angle_calc = 'along') +
# geom_point(aes(x = x, y = y)) +
# geom_node_label(size = 2, repel = TRUE) +
theme_void()
library(igraph)
library(tidygraph)
g2 <- graph_from_data_frame(forest_edge)
g2 |>
as_tbl_graph() |>
mutate(dist_to_center = node_distance_to(node_is_center())) %>%
ggraph(layout = 'kk') +
geom_edge_link() +
geom_node_point(aes(size = dist_to_center), colour = 'steelblue') +
scale_size_continuous(range = c(6, 1)) +
theme_graph()
library(tidygraph)
library(ggraph)
library(dplyr)
edgelist <- forest_edge
# Simple version using just source/target columns
visualize_rf_network_simple <- function(edgelist, min_connections = 10) {
# Create basic graph from source/target
graph <- tbl_graph(
edges = edgelist %>% select(from = source, to = target),
directed = TRUE
)
# Calculate node metrics
graph <- graph %>%
activate(nodes) %>%
mutate(
degree = centrality_degree(),
betweenness = centrality_betweenness()
)
# Sample if too large
if (ecount(graph) > 5000) {
graph <- graph %>%
activate(nodes) %>%
filter(degree >= min_connections) %>%
activate(edges) %>%
filter(!is.na(from) & !is.na(to))
}
ggraph(graph, layout = 'fr') +
geom_edge_link(alpha = 0.3, edge_colour = "gray40") +
geom_node_point(aes(size = degree), color = "steelblue", alpha = 0.7) +
scale_size_continuous(range = c(1, 8)) +
theme_graph() +
labs(title = "Random Forest Network Structure")
}
# Version with split_var grouping
visualize_rf_grouped <- function(edgelist, min_edge_count = 20, top_vars = 30) {
# Group edges by split_var
var_transitions <- edgelist %>%
group_by(split_var) %>%
mutate(
next_var = lead(split_var)
) %>%
ungroup() %>%
filter(!is.na(next_var)) %>%
count(split_var, next_var, name = "weight") %>%
filter(weight >= min_edge_count)
# Create graph from variable transitions
graph <- tbl_graph(
edges = var_transitions %>% rename(from = split_var, to = next_var),
directed = TRUE
)
# Add node statistics
graph <- graph %>%
activate(nodes) %>%
mutate(
in_deg = centrality_degree(mode = "in"),
out_deg = centrality_degree(mode = "out"),
total_deg = centrality_degree(mode = "all")
) %>%
# Keep top variables
top_n(top_vars, total_deg)
# Keep only edges between remaining nodes
graph <- graph %>%
activate(edges) %>%
filter(!edge_is_incident(which(.N()$name %in% .N()$name[is.na(.N()$total_deg)])))
# Visualize
ggraph(graph, layout = 'fr') +
geom_edge_link(
aes(width = weight, alpha = weight),
arrow = arrow(length = unit(2, 'mm'), type = "closed"),
end_cap = circle(2, 'mm'),
colour = "gray30"
) +
geom_node_point(
aes(size = total_deg),
color = "steelblue",
alpha = 0.8
) +
geom_node_text(aes(label = name), repel = TRUE, size = 3) +
scale_edge_width_continuous(range = c(0.5, 3)) +
scale_edge_alpha_continuous(range = c(0.3, 0.9), guide = "none") +
scale_size_continuous(range = c(3, 12)) +
theme_graph() +
labs(
title = "Variable Transition Network",
subtitle = sprintf("Top %d variables, edges with %d+ transitions",
top_vars, min_edge_count)
)
}
# Version with prediction values
visualize_rf_with_predictions <- function(edgelist, sample_size = 2000) {
# Sample if needed
if (nrow(edgelist) > sample_size) {
edgelist <- edgelist %>% sample_n(sample_size)
}
# Bin predictions for coloring
edgelist <- edgelist %>%
mutate(
pred_group = cut(prediction,
breaks = quantile(prediction, probs = c(0, 0.33, 0.67, 1)),
labels = c("Low", "Med", "High"),
include.lowest = TRUE)
)
# Create graph
graph <- tbl_graph(
edges = edgelist %>% select(from = source, to = target, pred_group),
directed = TRUE
)
# Color edges by prediction group
ggraph(graph, layout = 'stress') +
geom_edge_link(
aes(edge_colour = pred_group),
alpha = 0.4
) +
geom_node_point(size = 0.5, alpha = 0.5) +
scale_edge_color_manual(values = c("Low" = "blue", "Med" = "gray", "High" = "red")) +
theme_graph() +
labs(title = "Random Forest Flow by Prediction Values")
}
# Usage:
plot1 <- visualize_rf_network_simple(edgelist)
plot2 <- visualize_rf_grouped(edgelist)
plot3 <- visualize_rf_with_predictions(edgelist)
plot1
plot2
check()
document()
load_all()
document()
df <- data.frame(course = c("stat101", "stat102", "stat202", "math102", "data202"),
prereq = c("math101", "stat101", "stat101", NA, NA),
crosslist = c(NA, "math102", "data202", "stat102", "stat202"))
df
?rep
rep(c(1))
rep(c(1), 2)
load_all()
edges(df)
df
edges.data.frame(df)
load_all()
load_all()
edges.data.frame(df)
edges.data.frame(df, 1, c(2,3))
edges(df)
class(df)
methods("edges")
?methods
edges(df)
edges.data.frame(df)
load_all()
edges(df)
load_all()
edges(df)
load_all()
edges(df)
edges.data.frame(df)
edges(forest2)
methods("edges")
typeof(dg)
typeof(df
)
typeof(forest2)
load_all()
load_all()
document()
load_all()
edges(df)
edges.data.frame(df, 1, c(2,3))
check()
check()
check()
document()
document()
check()
document()
check()
load_all()
check()
load_all()
document()
check()
use_r("edges.xgboost")
use_r("edges.xgboost.R")
??xgboost
load_all()
library(devtools)
load_all()
check()
use_test()
use_test()
df <- data.frame(course = c("stat101", "stat102", "stat202", "math102", "data202"),
prereq = c("math101", "stat101", "stat101", NA, NA),
crosslist = c(NA, "math102", "data202", "stat102", "stat202"))
load_all()
nodes(df)
document()
load_all()
nodes(df)
?setdiff
load_all()
nodes(df)
nodes(df, 2)
nodes(df, "crosslist")
edges(df)
df
library(devtools)
#> Loading required package: usethis
usethis::use_vignette("the-basics")
load_all()
library(networkformat)
# replace with
library(igraph)
?edgelist
?edges
?igraph::edges()
